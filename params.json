{"name":"Glsl-image-maker","tagline":"A GPU demo that genetically(?) creates 3D data which projects into a given target image","body":"glsl-image-maker\r\n================\r\n\r\nThis is a WebGL/[GPGPU](http://en.wikipedia.org/wiki/General-purpose_computing_on_graphics_processing_units) demo I made to teach myself shader programming. It generates random 3D polygons which resemble a given target image when projected. Basically it's the concept from [this blog post](http://rogeralsing.com/2008/12/07/genetic-programming-evolution-of-mona-lisa/), but done in 3D and on the GPU.\r\n\r\n[image]\r\n\r\nAn explanatory blog post will be up shortly.\r\n\r\n### Live demos:\r\n\r\nHere is the [example client for creating a projection](). It's the same thing you'd get by running `npm start` on the module. Note that this project compares images on the GPU and reads back the results, which I assume won't work on some (older?) video cards.\r\n\r\nHere is a [demo viewer of a previously made projection](). It's the bundled output of `npm run viewer`.\r\n\r\n## Installation & Usage\r\n\r\n    git clone [this repo]\r\n    cd glsl-image-maker\r\n    npm install\r\n    npm start\r\n\r\nThat launches the demo client, a web page that provides a UI to the core library. Alternately run `npm run viewer` to see a simple projection viewer, or `npm run bundle` to browserify the examples.\r\n\r\nTo use the library directly:\r\n\r\n    var proj = require('path/to/glsl-image-maker/')\r\n    proj.init( glReference, imageReference )\r\n\r\n## API\r\n\r\n#### init (glRef, imageRef, size)\r\n\r\n * gl object of the canvas you'll use for output\r\n * [optional] source image (an HTML Image object)\r\n * [optional] resolution of the framebuffer used internally for comparison (default 256)\r\n\r\nIf no image is supplied, the library will initialize but assume you're going to use it to display data that was already created. (So calls to e.g. `runGeneration()` will fail.)\r\n\r\n#### runGeneration()\r\n\r\nRuns one generation of the genetic(?) algorithm - mutating the internal data and keeping the result if it scores higher than the previous version.\r\n\r\n#### paint( xRot, yRot )\r\n\r\nPaints the current best data to the gl context. Optionally takes x- and y-rotation [Euler] angles.\r\n\r\n#### paintReference()\r\n\r\nPaints the reference framebuffer to the gl context (this may differ from the reference image in resolution)\r\n\r\n#### paintScratchBuffer()\r\n\r\nPaints the internal comparison framebuffer\r\n\r\n#### exportData()\r\n\r\nExports the current polygon data, in an extremely dumb ad-hoc string format.\r\n\r\n#### importData(str)\r\n\r\nImports data in the same ad-hoc format as above.\r\n\r\n#### score \r\n\r\n(read only) Returns the score (fitness) of the current data. Scales roughly from -100 to 100.\r\n\r\n#### numPolys \r\n\r\n(read only) Number of polygons (triangles) currently used\r\n\r\n#### minAlpha / maxAlpha\r\n\r\n(defaults 0.05, 0.5) Min/max values the algorithm will use when randomizing any vertex's alpha value. I found that setting these moderately low (e.g. .1 to .5) made images get more interesting more quickly than just using the range 0..1.\r\n\r\n#### compareonGPU\r\n\r\n(default true) Flag for whether to use the GPU when comparing rendered images to the target image. Turning this off will slow things down a lot.\r\n\r\n#### fewerPolysTolerance\r\n\r\n(default 0) A tolerance within which the algorithm will accept generations with a lower score as long as they have fewer polygons than the previous. \r\n\r\n#### useFlatPolys\r\n\r\n(default false) When set, all new polygons will share a common z value (i.e. they will be parallel to the camera plane). I thought this might make for interesting visuals, but didn't get anywhere with it.\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}